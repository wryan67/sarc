#!/usr/bin/python3

import sys
import os
import hashlib
import argparse
import stat
import time
import signal
from datetime import datetime

VERSION = "1.25"
DELIM = 'Ã¾'

def parse_size(size_str):
    suffixes = {'b': 1, 'k': 1024, 'm': 1024**2, 'g': 1024**3, 't': 1024**4, 'p': 1024**5}
    size_str = size_str.lower()
    suffix = size_str[-1]
    if suffix in suffixes:
        return int(size_str[:-1]) * suffixes[suffix]
    return int(size_str)

def format_size(size, fixed_width=False, raw_bytes=False):
    if raw_bytes:
        val = str(size)
        if fixed_width:
            return f"{val:>12} B  "
        return f"{val} B"
    
    for unit in ['B', 'KiB', 'MiB', 'GiB', 'TiB']:
        if size < 1024:
            val = f"{size:.2f}"
            if fixed_width:
                return f"{val:>8} {unit:<3}"
            return f"{val} {unit}"
        size /= 1024
    val = f"{size:.2f}"
    if fixed_width:
        return f"{val:>8} PiB"
    return f"{val} PiB"

def get_index(f):
    f.seek(-19, os.SEEK_END)
    footer = f.read(19)
    index_size = int.from_bytes(footer[:8], 'little')
    magic = footer[8:].decode()
    if magic != "MYARCHIVEV1":
        print("ERROR: Invalid archive format.", file=sys.stderr)
        sys.exit(2)
    f.seek(-(19 + index_size), os.SEEK_END)
    return f.read(index_size).decode().strip().split('\n')

def list_contents(archive_path, raw_bytes=False):
    if not os.path.exists(archive_path):
        print(f"ERROR: Archive {archive_path} not found.", file=sys.stderr)
        sys.exit(2)
    with open(archive_path, 'rb') as f:
        index_lines = get_index(f)
        name_width = 20
        for line in index_lines:
            name_width = max(name_width, len(line.split(DELIM)[0]) + 2)
        
        if raw_bytes:
            # Numeric field is 12. "Size" (4) right-aligned in 12 + 2 spaces padding
            size_header = f"{'Size':>12}     "
        else:
            # Numeric field is 8. "Size" (4) right-aligned in 8 + 5 spaces padding
            size_header = f"{'Size':>8}     "
            
        header = f"{'Name':<{name_width}} {size_header} {'Timestamp':<20} {'SHA256 Checksum'}"
        checksum_len = 64
        total_width = name_width + 1 + len(size_header) + 1 + 20 + 1 + checksum_len
        print(header)
        print("-" * total_width)
        for line in index_lines:
            name, offset, size, sha256, mtime = line.split(DELIM)
            display_size = format_size(int(size), fixed_width=True, raw_bytes=raw_bytes)
            print(f"{name:<{name_width}} {display_size}  {mtime:<20} {sha256}")

def extract_contents(archive_path, targets=None, quiet=False, verbose=False, raw_bytes=False):
    if not os.path.exists(archive_path):
        print(f"ERROR: Archive {archive_path} not found.", file=sys.stderr)
        sys.exit(2)

    current_extracting_file = None

    def signal_handler(sig, frame):
        if current_extracting_file and os.path.exists(current_extracting_file):
            os.remove(current_extracting_file)
            sys.stderr.write(f"\nCleaning up: {current_extracting_file} deleted.\n")
        sys.stderr.write("user cancelled\n")
        sys.exit(2)

    signal.signal(signal.SIGINT, signal_handler)

    with open(archive_path, 'rb') as f:
        index_lines = get_index(f)
        
        filtered_items = []
        est_total_size = 0
        for line in index_lines:
            name, offset, size, sha256, mtime = line.split(DELIM)
            if targets and name not in targets:
                continue
            filtered_items.append((name, int(offset), int(size), sha256))
            est_total_size += int(size)

        total_written = 0
        start_time = time.time()
        last_update_time = 0

        for name, offset, size, sha256 in filtered_items:
            current_extracting_file = name
            if verbose:
                sys.stderr.write(f"\r\033[KExtracting: {name}\n")
            
            f.seek(offset)
            remaining = size
            sha256_hash = hashlib.sha256()
            
            with open(name, 'wb') as f_out:
                while remaining > 0:
                    chunk = f.read(min(remaining, 65536))
                    if not chunk: break
                    f_out.write(chunk)
                    sha256_hash.update(chunk)
                    chunk_len = len(chunk)
                    remaining -= chunk_len
                    total_written += chunk_len

                    if not quiet:
                        now = time.time()
                        if now - last_update_time >= 0.25:
                            elapsed = now - start_time
                            speed = total_written / elapsed if elapsed > 0 else 0
                            processed_str = format_size(total_written, fixed_width=True, raw_bytes=raw_bytes)
                            speed_str = format_size(speed, raw_bytes=raw_bytes)
                            out = f" {processed_str} [{speed_str}/s]"
                            if est_total_size > 0:
                                percent = (total_written / est_total_size) * 100
                                eta = (est_total_size - total_written) / speed if speed > 0 else 0
                                out += f" {percent:6.1f}% ETA: {int(eta//3600):02}:{int((eta%3600)//60):02}:{int(eta%60):02}"
                            sys.stderr.write(f"\r{out}\033[K\r")
                            sys.stderr.flush()
                            last_update_time = now
            
            if sha256_hash.hexdigest() != sha256:
                sys.stderr.write(f"\nWARNING: Checksum mismatch for {name}!\n")
            current_extracting_file = None

        if not quiet: sys.stderr.write("\n")

def archive(output_file, manifest, quiet=False, verbose=False, est_total_size=0, raw_bytes=False):
    if output_file in [None, "-"]:
        f_out = sys.stdout.buffer
        is_real_file = False
    else:
        f_out = open(output_file, 'wb')
        is_real_file = True

    try:
        index = []
        current_pos = 0
        total_written = 0
        start_time = time.time()
        last_update_time = 0

        for target_name, source_path in manifest:
            if verbose:
                sys.stderr.write(f"\r\033[KProcessing: {target_name}\n")

            if source_path == "-":
                f_in = sys.stdin.buffer
                mtime_raw = datetime.now().timestamp()
            else:
                st = os.stat(source_path)
                mtime_raw = datetime.now().timestamp() if stat.S_ISFIFO(st.st_mode) else st.st_mtime
                f_in = open(source_path, 'rb', buffering=0)

            mtime_str = datetime.fromtimestamp(mtime_raw).strftime('%Y-%m-%d %H:%M:%S')
            sha256_hash = hashlib.sha256()
            start_offset = current_pos
            size = 0
            
            try:
                while True:
                    chunk = f_in.read(65536)
                    if not chunk: break
                    f_out.write(chunk)
                    sha256_hash.update(chunk)
                    chunk_len = len(chunk)
                    size += chunk_len
                    current_pos += chunk_len
                    total_written += chunk_len

                    if not quiet:
                        now = time.time()
                        if now - last_update_time >= 0.25:
                            elapsed = now - start_time
                            speed = total_written / elapsed if elapsed > 0 else 0
                            processed_str = format_size(total_written, fixed_width=True, raw_bytes=raw_bytes)
                            speed_str = format_size(speed, raw_bytes=raw_bytes)
                            out = f" {processed_str} [{speed_str}/s]"
                            if est_total_size > 0:
                                percent = (total_written / est_total_size) * 100
                                eta = (est_total_size - total_written) / speed if speed > 0 else 0
                                out += f" {percent:6.1f}% ETA: {int(eta//3600):02}:{int((eta%3600)//60):02}:{int(eta%60):02}"
                            sys.stderr.write(f"\r{out}\033[K\r")
                            sys.stderr.flush()
                            last_update_time = now
            finally:
                if source_path != "-":
                    f_in.close()
            
            index.append(f"{target_name}{DELIM}{start_offset}{DELIM}{size}{DELIM}{sha256_hash.hexdigest()}{DELIM}{mtime_str}")

        if not quiet: sys.stderr.write("\n")
        index_data = "\n".join(index).encode()
        f_out.write(index_data)
        f_out.write(len(index_data).to_bytes(8, 'little'))
        f_out.write(b"MYARCHIVEV1")
        f_out.flush()
    finally:
        if is_real_file:
            f_out.close()

if __name__ == "__main__":
    class CustomFormatter(argparse.RawDescriptionHelpFormatter):
        def __init__(self, prog):
            super().__init__(prog, max_help_position=24)

    parser = argparse.ArgumentParser(
        description=f"Streaming Archiver (sarc); version {VERSION}",
        formatter_class=CustomFormatter,
        epilog="Examples:\n  Archive:  sarc -a backup.bin root.img::/dev/zvol/root\n  Extract:  sarc -a backup.bin -x [item ...]\n  List:     sarc -a backup.bin -l"
    )

    parser.add_argument("-a", "--archive", metavar="FILE", help="Archive filename (default: stdout '-')", default="-")
    parser.add_argument("-l", "--list", action="store_true", help="List contents of archive")
    parser.add_argument("-x", "--extract", action="store_true", help="Extract all or specific items")
    parser.add_argument("-f", "--file", metavar="FILE", help="Read manifest from file")
    parser.add_argument("-d", "--direct", action="store_true", help="Direct mode: use path as name")
    parser.add_argument("-q", "--quiet", action="store_true", help="Quiet mode (suppress progress)")
    parser.add_argument("-v", "--verbose", action="store_true", help="Verbose (show filenames)")
    parser.add_argument("-b", "--bytes", action="store_true", help="Show sizes in bytes (default: human-readable)")
    parser.add_argument("-s", "--size", metavar="SIZE", help="Estimated total size (e.g. 10g, 500m)")
    parser.add_argument("-V", "--version", action="version", version=f"sarc {VERSION}")
    parser.add_argument("manifest", nargs="*", help="Manifest [name::path] or extraction targets")

    args = parser.parse_args()

    if args.list:
        if args.archive == "-":
            print("ERROR: Cannot list contents of stdout/pipe.", file=sys.stderr)
            sys.exit(2)
        list_contents(args.archive, raw_bytes=args.bytes)
        sys.exit(0)

    if args.extract:
        if args.archive == "-":
            print("ERROR: Cannot extract from stdout/pipe.", file=sys.stderr)
            sys.exit(2)
        extract_contents(args.archive, args.manifest if args.manifest else None, quiet=args.quiet, verbose=args.verbose, raw_bytes=args.bytes)
        sys.exit(0)

    manifest_items = []
    stdin_count = 0
    raw_items = list(args.manifest)

    if args.file:
        with open(args.file, 'r') as f:
            raw_items.extend([line.strip() for line in f if line.strip()])

    for item in raw_items:
        if args.direct:
            manifest_items.append((item, item))
        elif "::" in item:
            pair = item.split("::", 1)
            if pair[1] == "-": stdin_count += 1
            manifest_items.append(pair)

    if not manifest_items:
        parser.print_help()
        sys.exit(2)

    if stdin_count > 1:
        print("ERROR: Only one manifest item can use stdin ('-').", file=sys.stderr)
        sys.exit(2)
    if args.archive == "-" and stdin_count > 0:
        print("ERROR: Cannot use stdin for input AND stdout for output simultaneously.", file=sys.stderr)
        sys.exit(2)

    est_size_bytes = parse_size(args.size) if args.size else 0

    try:
        archive(args.archive, manifest_items, quiet=args.quiet, verbose=args.verbose, est_total_size=est_size_bytes, raw_bytes=args.bytes)
    except KeyboardInterrupt:
        if args.archive != "-" and os.path.exists(args.archive):
            os.remove(args.archive)
            sys.stderr.write(f"\nCleaning up: {args.archive} deleted.\n")
        sys.stderr.write("user cancelled\n")
        sys.exit(2)
